use std::io;
use std::path::PathBuf;

use async_compression::tokio::bufread::GzipDecoder;
use futures_util::StreamExt;
use reqwest::Client;
use tokio_tar::Archive;
use tokio_util::io::StreamReader;
use tracing::info;

#[derive(Clone)]
pub(crate) struct DeploymentService {
  client: Client,
  webroot: PathBuf,
  root_domain: String,
}

impl DeploymentService {
  pub(crate) fn new(webroot: PathBuf, root_domain: String) -> Self {
    Self {
      client: Client::new(),
      webroot,
      root_domain,
    }
  }

  pub(crate) async fn deploy(
    &self,
    full_name: &str,
    token: &str,
    commit_id: &str,
    domain: &str,
  ) -> anyhow::Result<()> {
    let dist = self.webroot.join(format!("{domain}.{}", self.root_domain));

    if tokio::fs::try_exists(&dist).await? {
      info!("Cleaning existing {}", dist.to_str().unwrap_or("~invalid~"));
      tokio::fs::remove_dir_all(&dist).await?;
    }

    info!(
      "Deploying {full_name}#{commit_id} into {}",
      dist.to_str().unwrap_or("~invalid~")
    );

    let url = format!("https://github.com/{full_name}/tarball/{commit_id}");

    let stream = self
      .client
      .get(url)
      .bearer_auth(token)
      .send()
      .await?
      .error_for_status()?
      .bytes_stream()
      .map(|x| Ok::<_, io::Error>(x.unwrap()));

    let reader = StreamReader::new(stream);
    let decoder = GzipDecoder::new(reader);
    let mut archive = Archive::new(decoder);

    archive.unpack(&dist).await?;

    // fixing stupid extra folder generated by github
    let mut dir = tokio::fs::read_dir(&dist).await?;
    let entry = dir.next_entry().await?.unwrap();
    let entry = entry.path();

    let mut child = tokio::fs::read_dir(&entry).await?;
    while let Some(path) = child.next_entry().await? {
      tokio::fs::rename(path.path(), dist.join(path.file_name())).await?;
    }

    tokio::fs::remove_dir(entry).await?;

    Ok(())
  }
}

#[cfg(test)]
mod tests {
  use std::path::PathBuf;

  use crate::service::deployment::DeploymentService;

  #[tokio::test]
  async fn test_deployment_service() -> anyhow::Result<()> {
    let service = DeploymentService::new(PathBuf::from("."), "m4rc3l.de".to_string());

    service
      .deploy("MarcelCoding/zia",  "abc", "main", "zia")
      .await
  }
}
